import java.util.ArrayList;
import java.util.PriorityQueue;

public class App {

    public static void printCode(HuffmanNode root, String s){
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 

        if (root.left == null && root.right == null
            && Character.isLetter(root.ch)) { 
  
            // ch is the character in the node 
            System.out.println(root.ch + ":" + s); 
  
            return; 
        } 
  
        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
  
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.left, s + "0"); 
        printCode(root.right, s + "1"); 
    }
    public static void main(String[] args) throws Exception {

        //Reading file to get lists of characters and their frequencies plus number of letters 
        FileUtils myFileUtils = new FileUtils();
        ArrayList<Character> inputCharList = myFileUtils.getInputCharList();

        ArrayList<Integer> inputFreqList = myFileUtils.getInputFreqList();

        int numOfLetters = myFileUtils.getNumOfLetters();

        new HoffmanCoding(inputCharList, inputFreqList, numOfLetters);

        //build a string of binary numbers for each character in file
        //send the string along with root node for decoding

//  ***********************************
        // Create a priority queue pq
        // PriorityQueue<HuffmanNode> pq = new PriorityQueue<>(numOfLetters,new MyComparator());

        // for(int i = 0; i < numOfLetters; i++){
        //     //create a Huffman node and add to pq

        //     HuffmanNode hn = new HuffmanNode();
        //     hn.ch = inputCharList.get(i);
        //     hn.value = inputFreqList.get(i);
            
        //     hn.left = null;
        //     hn.right = null;

        //     pq.add(hn);
        // }

        // //create a root node
        // HuffmanNode root = null;

        // //Find two minimum values from the priroity queue
        // while(pq.size() > 1){

        //     //first min value
        //     HuffmanNode x = pq.peek();
        //     pq.poll();

        //     //second min value
        //     HuffmanNode y = pq.peek();
        //     pq.poll();

        //     //create internal node from the two nodes
        //     HuffmanNode internalNode = new HuffmanNode();

        //     //add the two nodes' values 
        //     internalNode.value = x.value + y.value;
        //     internalNode.ch = '-';

        //     //Assign x as the left node
        //     internalNode.left = x;

        //     //Assign y as the right node
        //     internalNode.right = y;

        //     //marking the new node as the root node
        //     root = internalNode;

        //     //Now add the new node inplace of x and y to the priority queue
        //     pq.add(internalNode);

        // }
        // System.out.println("Root node after adding is: "+root.value);

        // printCode(root,"");

//  ***********************************

    }
}
