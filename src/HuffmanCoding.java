import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.PriorityQueue;

public class HuffmanCoding extends HuffmanNode {
  ArrayList<Character> inputCharList;
  ArrayList<Integer> inputFreqList;
  int numOfLetters;
  String encodedString = "";
  HuffmanNode root;
  HashMap<Character,String> codeMap;
  String huffmanTree = "";
  


  public HuffmanCoding(ArrayList<Character> inputCharList, ArrayList<Integer> inputFreqList, int numOfLetters) {
    this.inputCharList = inputCharList;
    this.inputFreqList = inputFreqList;
    this.numOfLetters = numOfLetters;

    //to store binary codes of characters
    HashMap<Character,String> codeMap = new HashMap<>();

    // Create a priority queue pq
    PriorityQueue<HuffmanNode> pq = new PriorityQueue<>(numOfLetters,new MyComparator());

    for(int i = 0; i < numOfLetters; i++){
      //create a Huffman node and add to pq

      HuffmanNode hn = new HuffmanNode();
      hn.ch = inputCharList.get(i);
      hn.value = inputFreqList.get(i);
      hn.left = null;
      hn.right = null;
      pq.add(hn);
    }

      //create a root node
      HuffmanNode root = null;

      //Find two minimum values from the priroity queue
      while(pq.size() > 1){

        //first min value
        HuffmanNode x = pq.peek();
        pq.poll();

        //second min value
        HuffmanNode y = pq.peek();
        pq.poll();

        //create internal node from the two nodes
        HuffmanNode internalNode = new HuffmanNode();

        //add the two nodes' values 
        internalNode.value = x.value + y.value;
        internalNode.ch = '-';

        //Assign x as the left node
        internalNode.left = x;

        //Assign y as the right node
        internalNode.right = y;

        //marking the new node as the root node
        root = internalNode;

        //Now add the new node inplace of x and y to the priority queue
        pq.add(internalNode);
      }

        this.root = root;

        

        generateCode(root,codeMap,"");
      
        

  }

  private void generateCode(HuffmanNode root, HashMap<Character,String> codeMap ,String s){
    // base case; if the left and right are null 
    // then its a leaf node and we print 
    // the code s generated by traversing the tree. 

    if (root != null && root.left == null && root.right == null) { 

        // ch is the character in the node 
        //System.out.println(root.ch + ":" + s); 
        codeMap.put(root.ch, s);
        // encodedString += s;
        // return; 
    } 

    // if we go to left then add "0" to the code. 
    // if we go to the right add"1" to the code. 

    // recursive calls for left and 
    // right sub-tree of the generated tree. 

    if(root != null){
      generateCode(root.left, codeMap, s + "0"); 
      generateCode(root.right, codeMap, s + "1"); 
    }

    this.codeMap = codeMap;
    
}

  public String buildTree(HuffmanNode currentNode, String huffmanTree,int numOfLetters){

    // String huffmanTree = "";
    // HuffmanNode currentNode = root;
    // int numOfLetters = this.numOfLetters;

    while(numOfLetters != 0){

      //if no further nodes on left and right, this is a leaf node
      // for every leaf node we add a 1 and then the character stored in the node
      System.out.println("Character in node: "+currentNode.ch);
      System.out.println("Value in node: "+currentNode.value);
      if(currentNode.left == null && currentNode.right == null){
        System.out.println(currentNode.ch);
        String chInNode = Character.toString(ch);
        huffmanTree += "1" + chInNode; 
        numOfLetters--;   
      }

      //for every non-leaf (internal) node we add a 0
      else{
        if(currentNode.left != null){
          huffmanTree += "0";
          currentNode = currentNode.left;
          buildTree(currentNode, huffmanTree, numOfLetters);

        }

        if (currentNode.right != null){
          huffmanTree += "0";
          currentNode = currentNode.right;
          buildTree(currentNode, huffmanTree, numOfLetters);
        }
      }
    }
    
    return huffmanTree;
    
  }


  public String buildTreeInBits(HuffmanNode currentNode, String treeBits){

    if (currentNode != null && currentNode.left != null && currentNode.right != null){
      huffmanTree += treeBits;
    }
   
    System.out.println("Huffman tree: "+huffmanTree);
    
    if (currentNode != null && currentNode.left == null && currentNode.right == null) { 
      
      System.out.println("Current node value: "+currentNode.value);
      System.out.println("Leaf node");
      System.out.println("Character in leaf node: "+currentNode.ch);
      String chInNode = String.valueOf(currentNode.ch);
      huffmanTree += "1" + chInNode;
      // huffmanTree[0] += "1" + chInNode;

      System.out.println("Huffman tree: "+huffmanTree);


      }

    if(currentNode != null){


      buildTreeInBits(currentNode.left, "0"); 
      buildTreeInBits(currentNode.right, "0"); 
    }

    // if(currentNode.left != null){
    //   huffmanTree[0] += "0";
    //    System.out.println("Huffman tree: "+Arrays.toString(huffmanTree));

    //   buildTreeInBits(currentNode.left, huffmanTree); }

    // if(currentNode.right != null){ 
    //   huffmanTree[0] += "0";
    //    System.out.println("Huffman tree: "+Arrays.toString(huffmanTree));

    //   buildTreeInBits(currentNode.right, huffmanTree); 
    // }

    return huffmanTree;

  }




  
}
