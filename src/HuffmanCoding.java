import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;

public class HuffmanCoding extends HuffmanNode {
  ArrayList<Character> inputCharList;
  ArrayList<Integer> inputFreqList;
  int numOfLetters;
  String encodedString = "";
  HuffmanNode root;
  HashMap<Character,String> codeMap;
  


  public HuffmanCoding(ArrayList<Character> inputCharList, ArrayList<Integer> inputFreqList, int numOfLetters) {
    this.inputCharList = inputCharList;
    this.inputFreqList = inputFreqList;
    this.numOfLetters = numOfLetters;

    //to store binary codes of characters
    HashMap<Character,String> codeMap = new HashMap<>();

    // Create a priority queue pq
    PriorityQueue<HuffmanNode> pq = new PriorityQueue<>(numOfLetters,new MyComparator());

    for(int i = 0; i < numOfLetters; i++){
      //create a Huffman node and add to pq

      HuffmanNode hn = new HuffmanNode();
      hn.ch = inputCharList.get(i);
      hn.value = inputFreqList.get(i);
      hn.left = null;
      hn.right = null;
      pq.add(hn);
    }

      //create a root node
      HuffmanNode root = null;

      //Find two minimum values from the priroity queue
      while(pq.size() > 1){

        //first min value
        HuffmanNode x = pq.peek();
        pq.poll();

        //second min value
        HuffmanNode y = pq.peek();
        pq.poll();

        //create internal node from the two nodes
        HuffmanNode internalNode = new HuffmanNode();

        //add the two nodes' values 
        internalNode.value = x.value + y.value;
        internalNode.ch = '-';

        //Assign x as the left node
        internalNode.left = x;

        //Assign y as the right node
        internalNode.right = y;

        //marking the new node as the root node
        root = internalNode;

        //Now add the new node inplace of x and y to the priority queue
        pq.add(internalNode);
      }

        System.out.println("Root node after adding is: "+root.value);
        this.root = root;

        

        generateCode(root,codeMap,"");
      
        

  }

  public void generateCode(HuffmanNode root, HashMap<Character,String> codeMap ,String s){
    // base case; if the left and right are null 
    // then its a leaf node and we print 
    // the code s generated by traversing the tree. 

    if (root != null && root.left == null && root.right == null) { 

        // ch is the character in the node 
        System.out.println(root.ch + ":" + s); 
        codeMap.put(root.ch, s);
        // encodedString += s;
        // return; 
    } 

    // if we go to left then add "0" to the code. 
    // if we go to the right add"1" to the code. 

    // recursive calls for left and 
    // right sub-tree of the generated tree. 

    if(root != null){
      generateCode(root.left, codeMap, s + "0"); 
      generateCode(root.right, codeMap, s + "1"); 
    }

    this.codeMap = codeMap;
    
}
  
}
